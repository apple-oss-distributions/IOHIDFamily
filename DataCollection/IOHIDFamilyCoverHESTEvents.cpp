// This file was automatically generated by protocompiler
// DO NOT EDIT!
// Compiled from stdin

#include "IOHIDFamilyCoverHESTEvents.hpp"

namespace awdmetrics {

IOHIDFamilyCoverHESTEvents::IOHIDFamilyCoverHESTEvents() noexcept
{
    memset(&_has, 0, sizeof(_has));
}

IOHIDFamilyCoverHESTEvents::~IOHIDFamilyCoverHESTEvents() noexcept = default;

IOHIDFamilyCoverHESTEvents::IOHIDFamilyCoverHESTEvents(const IOHIDFamilyCoverHESTEvents &copy) noexcept
{
    memset(&_has, 0, sizeof(_has));
    if (copy.hasTimestamp()) { timestamp(copy.timestamp()); }
    if (copy.hasOpenCount()) { openCount(copy.openCount()); }
    if (copy.hasCloseCount()) { closeCount(copy.closeCount()); }
    if (copy.hasToggled50ms()) { toggled50ms(copy.toggled50ms()); }
    if (copy.hasToggled50100ms()) { toggled50100ms(copy.toggled50100ms()); }
    if (copy.hasToggled100250ms()) { toggled100250ms(copy.toggled100250ms()); }
    if (copy.hasToggled250500ms()) { toggled250500ms(copy.toggled250500ms()); }
    if (copy.hasToggled5001000ms()) { toggled5001000ms(copy.toggled5001000ms()); }
    if (copy.hasUnknownStateEnter()) { unknownStateEnter(copy.unknownStateEnter()); }
    if (copy.hasUnknownStateExit()) { unknownStateExit(copy.unknownStateExit()); }
}

IOHIDFamilyCoverHESTEvents& IOHIDFamilyCoverHESTEvents::operator=(const IOHIDFamilyCoverHESTEvents &copy) noexcept
{
    if (this == &copy) return *this;
    IOHIDFamilyCoverHESTEvents tmp{copy};
    swap(*this, tmp);
    return *this;
}

IOHIDFamilyCoverHESTEvents::IOHIDFamilyCoverHESTEvents(IOHIDFamilyCoverHESTEvents &&other) noexcept
{
    memcpy(&_has, &other._has, sizeof(_has));
    memset(&other._has, 0, sizeof(_has));
    _timestamp = std::move(other._timestamp);
    _openCount = std::move(other._openCount);
    _closeCount = std::move(other._closeCount);
    _toggled50ms = std::move(other._toggled50ms);
    _toggled50100ms = std::move(other._toggled50100ms);
    _toggled100250ms = std::move(other._toggled100250ms);
    _toggled250500ms = std::move(other._toggled250500ms);
    _toggled5001000ms = std::move(other._toggled5001000ms);
    _unknownStateEnter = std::move(other._unknownStateEnter);
    _unknownStateExit = std::move(other._unknownStateExit);
}

IOHIDFamilyCoverHESTEvents& IOHIDFamilyCoverHESTEvents::operator=(IOHIDFamilyCoverHESTEvents &&other) noexcept
{
    if (this == &other) return *this;
    IOHIDFamilyCoverHESTEvents tmp{std::move(other)};
    swap(*this, tmp);
    return *this;
}

void swap(IOHIDFamilyCoverHESTEvents &a, IOHIDFamilyCoverHESTEvents &b) noexcept
{
    using std::swap;
    swap(a._has, b._has);
    swap(a._timestamp, b._timestamp);
    swap(a._openCount, b._openCount);
    swap(a._closeCount, b._closeCount);
    swap(a._toggled50ms, b._toggled50ms);
    swap(a._toggled50100ms, b._toggled50100ms);
    swap(a._toggled100250ms, b._toggled100250ms);
    swap(a._toggled250500ms, b._toggled250500ms);
    swap(a._toggled5001000ms, b._toggled5001000ms);
    swap(a._unknownStateEnter, b._unknownStateEnter);
    swap(a._unknownStateExit, b._unknownStateExit);
}

void IOHIDFamilyCoverHESTEvents::formatText(PB::TextFormatter &formatter, const char *tag) const
{
    formatter.beginObject(tag);
    if (_has.closeCount) { formatter.format("close_count", _closeCount); }
    if (_has.openCount) { formatter.format("open_count", _openCount); }
    if (_has.timestamp) { formatter.format("timestamp", _timestamp); }
    if (_has.toggled100250ms) { formatter.format("toggled_100_250ms", _toggled100250ms); }
    if (_has.toggled250500ms) { formatter.format("toggled_250_500ms", _toggled250500ms); }
    if (_has.toggled5001000ms) { formatter.format("toggled_500_1000ms", _toggled5001000ms); }
    if (_has.toggled50100ms) { formatter.format("toggled_50_100ms", _toggled50100ms); }
    if (_has.toggled50ms) { formatter.format("toggled_50ms", _toggled50ms); }
    if (_has.unknownStateEnter) { formatter.format("unknownStateEnter", _unknownStateEnter); }
    if (_has.unknownStateExit) { formatter.format("unknownStateExit", _unknownStateExit); }
    formatter.endObject();
}

bool IOHIDFamilyCoverHESTEvents::readFrom(PB::Reader &reader) {
    while (reader.hasMore()) {
        uint32_t tag = 0;
        uint8_t aType = 0;

        reader.readTagAndType(tag, aType);

        if (reader.hasError())
            break;

        if (aType == TYPE_END_GROUP) {
            break;
        }

        switch (tag) {

            case 1 /* timestamp */:
            {
                _has.timestamp = true;
                reader.readVarInt(_timestamp);
            }
            break;
            case 2 /* openCount */:
            {
                _has.openCount = true;
                reader.readVarInt(_openCount);
            }
            break;
            case 3 /* closeCount */:
            {
                _has.closeCount = true;
                reader.readVarInt(_closeCount);
            }
            break;
            case 4 /* toggled50ms */:
            {
                _has.toggled50ms = true;
                reader.readVarInt(_toggled50ms);
            }
            break;
            case 5 /* toggled50100ms */:
            {
                _has.toggled50100ms = true;
                reader.readVarInt(_toggled50100ms);
            }
            break;
            case 6 /* toggled100250ms */:
            {
                _has.toggled100250ms = true;
                reader.readVarInt(_toggled100250ms);
            }
            break;
            case 7 /* toggled250500ms */:
            {
                _has.toggled250500ms = true;
                reader.readVarInt(_toggled250500ms);
            }
            break;
            case 8 /* toggled5001000ms */:
            {
                _has.toggled5001000ms = true;
                reader.readVarInt(_toggled5001000ms);
            }
            break;
            case 9 /* unknownStateEnter */:
            {
                _has.unknownStateEnter = true;
                reader.readVarInt(_unknownStateEnter);
            }
            break;
            case 10 /* unknownStateExit */:
            {
                _has.unknownStateExit = true;
                reader.readVarInt(_unknownStateExit);
            }
            break;
            default:
                if (!reader.skip(tag, aType))
                    return false;
                break;
        }
    }
    return !reader.hasError();
}

void IOHIDFamilyCoverHESTEvents::writeTo(PB::Writer &writer) const
{
    /* timestamp */
    {
        if (_has.timestamp)
        {
            writer.writeVarInt(_timestamp, 1);
        }
    }
    /* openCount */
    {
        if (_has.openCount)
        {
            writer.writeVarInt(_openCount, 2);
        }
    }
    /* closeCount */
    {
        if (_has.closeCount)
        {
            writer.writeVarInt(_closeCount, 3);
        }
    }
    /* toggled50ms */
    {
        if (_has.toggled50ms)
        {
            writer.writeVarInt(_toggled50ms, 4);
        }
    }
    /* toggled50100ms */
    {
        if (_has.toggled50100ms)
        {
            writer.writeVarInt(_toggled50100ms, 5);
        }
    }
    /* toggled100250ms */
    {
        if (_has.toggled100250ms)
        {
            writer.writeVarInt(_toggled100250ms, 6);
        }
    }
    /* toggled250500ms */
    {
        if (_has.toggled250500ms)
        {
            writer.writeVarInt(_toggled250500ms, 7);
        }
    }
    /* toggled5001000ms */
    {
        if (_has.toggled5001000ms)
        {
            writer.writeVarInt(_toggled5001000ms, 8);
        }
    }
    /* unknownStateEnter */
    {
        if (_has.unknownStateEnter)
        {
            writer.writeVarInt(_unknownStateEnter, 9);
        }
    }
    /* unknownStateExit */
    {
        if (_has.unknownStateExit)
        {
            writer.writeVarInt(_unknownStateExit, 10);
        }
    }
}

bool IOHIDFamilyCoverHESTEvents::operator==(const IOHIDFamilyCoverHESTEvents &other) const
{
    return true
    &&
    ((_has.timestamp && other._has.timestamp && _timestamp == other._timestamp) || (!_has.timestamp && !other._has.timestamp))
    &&
    ((_has.openCount && other._has.openCount && _openCount == other._openCount) || (!_has.openCount && !other._has.openCount))
    &&
    ((_has.closeCount && other._has.closeCount && _closeCount == other._closeCount) || (!_has.closeCount && !other._has.closeCount))
    &&
    ((_has.toggled50ms && other._has.toggled50ms && _toggled50ms == other._toggled50ms) || (!_has.toggled50ms && !other._has.toggled50ms))
    &&
    ((_has.toggled50100ms && other._has.toggled50100ms && _toggled50100ms == other._toggled50100ms) || (!_has.toggled50100ms && !other._has.toggled50100ms))
    &&
    ((_has.toggled100250ms && other._has.toggled100250ms && _toggled100250ms == other._toggled100250ms) || (!_has.toggled100250ms && !other._has.toggled100250ms))
    &&
    ((_has.toggled250500ms && other._has.toggled250500ms && _toggled250500ms == other._toggled250500ms) || (!_has.toggled250500ms && !other._has.toggled250500ms))
    &&
    ((_has.toggled5001000ms && other._has.toggled5001000ms && _toggled5001000ms == other._toggled5001000ms) || (!_has.toggled5001000ms && !other._has.toggled5001000ms))
    &&
    ((_has.unknownStateEnter && other._has.unknownStateEnter && _unknownStateEnter == other._unknownStateEnter) || (!_has.unknownStateEnter && !other._has.unknownStateEnter))
    &&
    ((_has.unknownStateExit && other._has.unknownStateExit && _unknownStateExit == other._unknownStateExit) || (!_has.unknownStateExit && !other._has.unknownStateExit))
    ;
}

std::size_t IOHIDFamilyCoverHESTEvents::hash_value() const
{
    return 0
    ^
    (_has.timestamp ? std::hash<uint64_t>()(_timestamp) : 0)
    ^
    (_has.openCount ? std::hash<uint32_t>()(_openCount) : 0)
    ^
    (_has.closeCount ? std::hash<uint32_t>()(_closeCount) : 0)
    ^
    (_has.toggled50ms ? std::hash<uint32_t>()(_toggled50ms) : 0)
    ^
    (_has.toggled50100ms ? std::hash<uint32_t>()(_toggled50100ms) : 0)
    ^
    (_has.toggled100250ms ? std::hash<uint32_t>()(_toggled100250ms) : 0)
    ^
    (_has.toggled250500ms ? std::hash<uint32_t>()(_toggled250500ms) : 0)
    ^
    (_has.toggled5001000ms ? std::hash<uint32_t>()(_toggled5001000ms) : 0)
    ^
    (_has.unknownStateEnter ? std::hash<uint32_t>()(_unknownStateEnter) : 0)
    ^
    (_has.unknownStateExit ? std::hash<uint32_t>()(_unknownStateExit) : 0)
    ;
}

}; // end namespace awdmetrics

